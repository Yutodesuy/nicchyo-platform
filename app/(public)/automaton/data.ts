export interface Problem {
  id: string;
  question: string;
  answer: string;
  explanation: string;
  formalProof: string;
  commonMistakes: string;
}

export const problems: Problem[] = [
  // Section 3: Computability Theory
  {
    id: "3.1",
    question: "言語 {w]w : w ∈ {0,1}*} を判定する Turing 機械の正式な記述を与えよ。",
    answer: "入力の中間点を見つけ、左右対称に文字を比較する。",
    explanation: "テープ上の ']' を探し、その左右の文字列が一致するかを確認します。最初の文字をマークし、']' の後の対応する文字をマークして比較、という手順を繰り返します。",
    formalProof: `Turing機械 M = (Q, Σ, Γ, δ, q0, qaccept, qreject) を構成する。
Σ = {0, 1, ]}, Γ = {0, 1, ], x, _}。
動作:
1. 入力を左から右へ走査し、']' がちょうど1つ存在することを確認する。なければ reject。
2. ヘッドをテープ先頭に戻す。
3. 以下を繰り返す:
   a. 現在のセルが 'x' なら右へ進む。
   b. ']' なら、すべての文字が照合済みか確認する。右側の文字がすべて 'x' なら accept、そうでなければ reject。
   c. '0' または '1' なら、その文字を記号 'x' に書き換え、その文字種 (0 or 1) を状態に記憶する。
   d. 右へ移動し、']' を超えて、最初の 'x' でない文字を探す。
   e. その文字が記憶した文字と一致すれば、その文字を 'x' に書き換える。不一致、または文字がない（空白）なら reject。
   f. ヘッドを左へ移動し、']' の左側の最初の 'x' まで戻り、その一つ右（未処理の文字）へ移動する。
4. すべての文字が正しく照合されれば accept。`,
    commonMistakes: "w が空文字列の場合（入力が ']' のみ）や、左右の長さが異なる場合の処理を忘れないようにしましょう。また、比較済みの文字をスキップするロジックを正確に記述する必要があります。"
  },
  {
    id: "3.2",
    question: "以下の言語を判定する Turing 機械の記述を与えよ: (1) {a^i b^j c^k : i×j=k, i,j,k ≥ 1}, (2) {]x_1]x_2]... ]x_l : x_i ∈ {0,1}* and ∀i≠j, x_i ≠ x_j}",
    answer: "(1) 乗算をシミュレートする (2) 全ペアを比較する",
    explanation: "(1) aの数をカウントし、bの数をその回数分足し合わせ、cの数と一致するか確認します。(2) リスト内の全てのペア (x_i, x_j) について、それらが異なることを確認します。",
    formalProof: `(1) M1 の動作:
1. 入力が a^+ b^+ c^+ の形式か確認。
2. テープ先頭に戻る。
3. a を1つ 'x' に消すたびに、b の列全体を走査し、対応する数の c を 'z' に消す（b の個数分だけ c を消す）。
   - b の走査中に c が足りなくなれば reject。
4. b の走査が終わるたびに b のマークを復元し、次の a を処理する。
5. すべての a を処理した後、c が残っていなければ accept、残っていれば reject。

(2) M2 の動作:
1. 入力形式を確認。
2. 各 x_i について、それより後ろにあるすべての x_j (j > i) と比較する。
   - x_i の開始位置に印をつけ、x_j の開始位置を探す。
   - x_i と x_j を1文字ずつ比較する。
   - 一致してしまった場合（最後まで一致し、かつ終端記号 ']' または空白に同時に到達した場合）、reject。
3. すべてのペアの比較が終了し、重複がなければ accept。`,
    commonMistakes: "(1) では乗算を「足し算の繰り返し」として実装する際、bのマークを復元（アンマーク）する手順を忘れると、次のaに対する処理でbが使えなくなってしまいます。(2) では自分自身との比較や、逆順のペア (j, i) の重複チェックを効率的に扱う必要があります（i < j のペアだけ見れば十分）。"
  },
  {
    id: "3.3",
    question: "Σ={0,1}。以下の言語を判定する Turing 機械: (1) {w : #0(w) = #1(w)}, (2) {w : #0(w) = 2 × #1(w)}, (3) {w : #0(w) ≠ 2 × #1(w)}",
    answer: "対応する文字を消去していく。",
    explanation: "(1) 0を見つけたら1を探して消す。(2) 1を見つけたら0を2つ探して消す。(3) (2)の判定結果を反転させる。",
    formalProof: `(1) M1:
1. 左から右へ走査し、未処理の 0 を見つけたら x に書き換え、対応する未処理の 1 を探して x に書き換える。見つからなければ reject。
2. 未処理の 1 を見つけたら x に書き換え、対応する未処理の 0 を探して x に書き換える。
3. テープ上のすべての 0, 1 が消えたら accept。余ったら reject。

(2) M2:
1. 左から右へ走査し、未処理の 1 を見つけたら x に書き換える。
2. その後、テープ全体から未処理の 0 を2つ探し、それぞれ x に書き換える。2つ見つからなければ reject。
3. すべての 1 が処理されたとき、0 もすべて処理されていれば accept。そうでなければ reject。

(3) M3:
1. M2 をサブルーチンとして実行する。
2. M2 が accept なら reject、M2 が reject なら accept する。`,
    commonMistakes: "(2) において、1つ目の0は見つかったが2つ目の0がない場合の処理に注意してください。また、(3) は (2) の補集合ですが、入力形式が不正な場合（例えば Σ={0,1} 以外の文字が含まれる場合など）の扱いに注意が必要です（通常は文法違反もreject）。"
  },
  {
    id: "3.4",
    question: "ヘッドの静止 'S' を許す TM は、通常の TM (L, R のみ) と等価であることを示せ。",
    answer: "S 動作を R, L 動作で置換する。",
    explanation: "その場に留まる動作は、右に行ってすぐ左に戻る動作と同じです。",
    formalProof: `静止移動 S を持つ TM M_S を考える。通常の TM M_std を以下のように構成する。
M_S の遷移関数 δ_S(q, a) = (q', b, S) がある場合、M_std では新しい中間状態 q_temp を導入し、以下の2つの遷移に置き換える：
1. δ_std(q, a) = (q_temp, b, R)
2. δ_std(q_temp, c) = (q', c, L) （任意の記号 c ∈ Γ に対して）
これにより、ヘッドは右に移動してから直ちに左に戻り、元の位置で状態 q' に遷移し、テープ内容は b に書き換えられる。これは S 動作と等価である。`,
    commonMistakes: "テープの右端で「右へ行って戻る」操作をすると、無限テープの仮定が必要になります。片側無限テープの場合、左端での挙動（左に行けない場合）に注意が必要ですが、通常は「右へ行って戻る」で問題ありません。"
  },
  {
    id: "3.5",
    question: "任意の言語 A に対して、(i) A を判定する非決定性 TM (NTM) が存在する ⇔ (ii) A は判定可能である (DTM で判定可能)。",
    answer: "DTM は NTM をシミュレートできる。",
    explanation: "NTM の計算木を幅優先探索 (BFS) することで、有限ステップで受理状態に到達するかを確認できます。A が判定可能なら自明に NTM も存在します。",
    formalProof: `(ii) ⇒ (i): DTM は NTM の特殊ケース（選択肢が常に1つ）であるため自明。
(i) ⇒ (ii): NTM N が A を判定するとする。N の計算は木構造をなす。N は decider なので、全ての計算枝は有限長で停止する。
DTM D を構成し、N をシミュレートする。D は N の計算木を幅優先探索する。
具体的には、深さ k = 1, 2, ... について、長さ k の全ての可能な遷移列を試す。
N がある枝で accept すれば D も accept する。
N の全ての枝が reject して停止する場合、D もそれを確認して reject する。
（N が decider なら木は有限であるため、D は必ず停止する。）`,
    commonMistakes: "深さ優先探索 (DFS) でシミュレートしようとすると、ある計算パスが無限ループした場合（判定機でない場合）に、他の受理パスを見つけられなくなる可能性があります。判定機（decider）の前提があればDFSでも停止しますが、一般的な認識機（recognizer）の場合はBFSが必須です。"
  },
  {
    id: "3.6",
    question: "列挙装置 (Enumerator) の正式な定義を与えよ。",
    answer: "2テープTMで、一方をプリンタとして使用する。",
    explanation: "計算を行いながら、特定の状態に入ったときにテープの内容を「出力」したとみなす機械です。",
    formalProof: `列挙装置 E は、2テープ Turing 機械の一種であり、(Q, Σ, Γ, δ, q0, qprint) で定義される。
- テープ1: 作業用テープ（読み書き可）
- テープ2: 出力用テープ（初期は空白、ヘッドは右移動のみ）
動作:
計算の過程で状態 qprint に到達したとき、テープ2に書かれている内容（区切り文字で区切られた文字列）が出力されたとみなす。
E が生成する言語 L(E) は、E が（無限の時間実行した結果として）出力する文字列全体の集合である。
L(E) = { w | E がある時点で w を出力テープに書き込み、qprint に入る }。`,
    commonMistakes: "列挙される文字列の順序（辞書順である必要はない）や、重複（同じ文字列を何度出力してもよい）についての条件を勝手に厳しくしないようにしましょう。単純に「出力される集合」が言語と定義されます。"
  },
  {
    id: "3.7",
    question: "任意の言語 A に対して、(i) A を列挙する列挙装置が存在する ⇔ (ii) A は Turing 認識可能である。",
    answer: "認識可能なら列挙でき、列挙できるなら認識できる。",
    explanation: "認識可能なら、すべての文字列を並列にシミュレートして受理した順に出力できます。列挙できるなら、入力が出力されるのを待てばよいです。",
    formalProof: `(i) ⇒ (ii): A を列挙する E があるとする。A を認識する TM M を構成する。
M(w):
  1. E を実行する。
  2. E が文字列 s を出力するたびに、w と s を比較する。
  3. w = s ならば accept する。
(w ∈ A なら E はいつか w を出力するので M は停止して accept する。w ∉ A なら M はループし続ける。これは認識可能の定義に合致する)

(ii) ⇒ (i): A を認識する TM M があるとする。A を列挙する E を構成する。
E:
  1. i = 1, 2, 3, ... と増やす。
  2. 長さ i 以下のすべての文字列 s_1, ..., s_k を生成する。
  3. 各 s_j について、M を i ステップだけ実行する。
  4. もし M が s_j を受理したら、s_j を出力する。
（この方法ですべての受理される文字列はいずれ出力される。）`,
    commonMistakes: "(ii)⇒(i) の証明で、文字列 s_1, s_2... に対して順番に M を実行してしまうと、s_1 でループした場合に s_2 以降が出力されなくなります。「i ステップだけ実行」という並列シミュレーション（ドーヴテイル法）が不可欠です。"
  },
  {
    id: "3.8",
    question: "1回書き込み TM (各セルへの書き込みは1回のみ) は、通常の TM と等価であることを示せ。",
    answer: "書き込み履歴を新しい領域にコピーしてシミュレートする。",
    explanation: "テープ上の値を書き換えたい場合、新しい場所に「新しい値」を持つテープの状態をコピーして再現すれば、書き換えなしで計算を進められます。",
    formalProof: `通常の TM M を 1回書き込み TM M' でシミュレートする。
M' はテープ内容の「更新履歴」を保持する。
テープ上の値を変える代わりに、M' は現在のテープ内容全体（または変更部分）をテープの未使用的領域にコピーし、そこで変更を行う。
具体的には、テープを「仮想的な時刻 t におけるテープ内容」のブロックとして管理する。
時刻 t の内容を読み取り、時刻 t+1 の内容を新しい領域に書き込む。
各セルは1回しか書き込まれない（新しい領域に書くため）。テープは無限にあるため、このシミュレーションは可能である。`,
    commonMistakes: "「書き込めないなら計算できない」と直感的に思いがちですが、テープが無限であることを利用して、空間を時間の代わりに消費することで解決できる点を見落とさないようにしましょう。"
  },
  {
    id: "3.9",
    question: "A_CFG = { <G, w> : G は w を生成する CFG } が判定可能であることを示せ。",
    answer: "Chomsky標準形に変換し、CYK法を用いる。",
    explanation: "文脈自由文法を扱いやすい形（CNF）に変換すると、文字列 w の長さ n に対して O(n^3) で生成可能か判定できます。",
    formalProof: `TM M を以下のように構成する。
M(<G, w>):
1. 文法 G を Chomsky 標準形 (CNF) に変換する。
2. 入力 w の長さを n とする。もし n=0 (w=ε) なら、G が S → ε を持つか確認して判定する。
3. n > 0 の場合、CYK アルゴリズムを実行する。
   - n × n のテーブルを作成する。
   - ボトムアップに、部分文字列 w[i:j] を生成可能な非終端記号の集合を計算する。
4. テーブルの頂点 (全体 w) に開始記号 S が含まれていれば accept、そうでなければ reject。
CYK法は有限ステップで終了するため、これは判定可能である。`,
    commonMistakes: "w が空文字列 (ε) の場合、Chomsky標準形では扱えない（あるいは S→ε のみが特別に許される）ため、別ケースとして処理する必要があります。ここを見落としがちです。"
  },
  {
    id: "3.10",
    question: "E_CFG = { <G> : L(G) = ∅ } が判定可能であることを示せ。",
    answer: "生成可能な非終端記号をマークする。",
    explanation: "終端記号のみから生成できる変数をボトムアップに特定していき、開始記号 S がマークされるかを確認します。",
    formalProof: `TM R を以下のように構成する。
R(<G>):
1. 文法 G の変数のうち、終端記号列を生成できるものをマークする。
   - 最初、すべての終端記号を生成可能とする。
   - 規則 A → U1...Uk において、右辺の記号がすべてマーク済みならば、A をマークする。
   - 新しい変数がマークされなくなるまで繰り返す。
2. 開始記号 S がマークされていなければ（S から終端記号列を導出できなければ） accept、そうでなければ reject。`,
    commonMistakes: "「すべての文字列 w に対して A_CFG を試す」という方法は、文字列が無限にあるため停止しません。文法の構造そのものを解析する必要がある点に注意してください。"
  },
  {
    id: "3.11",
    question: "EQ_CFG = { <G, H> : L(G) = L(H) } が判定不可能であることを示せ。",
    answer: "ALL_CFG からの帰着。",
    explanation: "すべての文字列を生成する文法との等価性判定 (ALL_CFG) は判定不能であることが知られています。",
    formalProof: `ALL_CFG = { <G> : L(G) = Σ* } は判定不可能である（PCPからの帰着などで示される）。
EQ_CFG が判定可能であると仮定し、その決定機を R とする。
ALL_CFG を判定する TM S を構成する:
S(<G>):
1. Σ* を生成する文法 H を構成する（これは簡単）。
2. R(<G, H>) を実行する。
3. R が accept なら accept、reject なら reject。
もし R が存在すれば S も存在することになるが、ALL_CFG は判定不可能なので矛盾。
よって EQ_CFG は判定不可能である。`,
    commonMistakes: "正規言語 (DFA/NFA) の場合は等価性判定が可能ですが、文脈自由言語では判定不能になります。この違いを混同しないようにしましょう。"
  },
  {
    id: "3.12",
    question: "A_TM = { <M, w> : M は w を受理する } が Turing 認識可能であることを示せ。",
    answer: "万能 Turing 機械 (Universal TM) を構成する。",
    explanation: "入力された M の記述に従って、w 上での動作をステップごとに実行すればよいです。",
    formalProof: `以下の TM U（万能 Turing 機械）を構成する。
U(<M, w>):
1. 入力 <M, w> が正当な TM の記述か確認する。
2. M のテープ内容、現在の状態、ヘッド位置を U のテープ上で管理する。
3. M の遷移関数 δ に従って、1ステップずつシミュレーションを行う。
4. M が accept 状態に入れば、U も accept する。
5. M が reject 状態に入れば、U も reject する。
もし M がループすれば U もループする。よって U は A_TM を認識する（判定はしない）。`,
    commonMistakes: "U が停止することを要求してはいけません。M がループする場合、U もループし続けることで「受理しない（拒否も停止もしない）」という正しい認識機の振る舞いになります。"
  },
  {
    id: "3.13",
    question: "写像帰着 ≤m が推移律を満たすことを示せ。A ≤m B かつ B ≤m C ならば A ≤m C。",
    answer: "変換関数の合成 f(g(x)) を用いる。",
    explanation: "AをBに変換する関数 f と、BをCに変換する関数 g があれば、それらを合成した g(f(x)) は A を C に変換します。",
    formalProof: `A ≤m B より、計算可能関数 f: Σ* → Σ* が存在し、w ∈ A ⇔ f(w) ∈ B。
B ≤m C より、計算可能関数 g: Σ* → Σ* が存在し、x ∈ B ⇔ g(x) ∈ C。
合成関数 h(w) = g(f(w)) を考える。
1. f, g は計算可能なので、その合成 h も計算可能である（fの出力をgの入力とするTMを作れる）。
2. w ∈ A ⇔ f(w) ∈ B ⇔ g(f(w)) ∈ C ⇔ h(w) ∈ C。
よって h は A から C への写像帰着であり、A ≤m C である。`,
    commonMistakes: "帰着に用いる関数 f, g は「全域で停止する（必ず出力を返す）」計算可能関数である必要があります。部分関数ではない点に注意してください。"
  },
  {
    id: "3.14",
    question: "A_TM は E_TM へ写像帰着可能でないことを示せ。",
    answer: "A_TM は RE だが、E_TM は RE でない。",
    explanation: "もし A_TM ≤m E_TM なら、A_TM の補問題も E_TM の補問題に帰着されますが、クラスの性質が矛盾します。",
    formalProof: `背理法で示す。A_TM ≤m E_TM と仮定する。
これは A_TM^c ≤m E_TM^c (補問題同士の帰着) を意味しないが、包含関係の矛盾を使う。
A_TM は RE (認識可能) であるが co-RE (補問題が認識可能) ではない。
一方、E_TM = { <M> : L(M)=∅ } の補問題 E_TM^c = { <M> : L(M)≠∅ } は RE である（入力を並列シミュレーションして受理するものが見つかれば停止できる）。
したがって E_TM は co-RE である。
もし A_TM ≤m E_TM ならば、A_TM^c ≤m E_TM^c となり、E_TM^c は RE なので A_TM^c も RE となるはずである。
しかし A_TM^c は RE でない（A_TM は判定可能でないため）。
矛盾が生じるため、帰着は存在しない。`,
    commonMistakes: "帰着が可能かどうかの議論で、単に「意味が違うから」とするのは間違いです。計算量クラス（RE, co-RE）の包含関係を用いて厳密に示す必要があります。"
  },
  {
    id: "3.15",
    question: "A が RE (認識可能) であり、A ≤m A^c ならば、A は判定可能であることを示せ。",
    answer: "A と A^c が共に RE となり、判定可能となる。",
    explanation: "A ≤m A^c ならば、A^c の認識機を使って A の補問題を認識できます。A と Aの補問題が両方認識可能なら、Aは判定可能です。",
    formalProof: `1. A ≤m A^c より、A^c ≤m (A^c)^c = A である（同じ帰着関数 f を用いる: w ∈ A ⇔ f(w) ∈ A^c より w ∈ A^c ⇔ f(w) ∈ A）。
2. A は RE である（仮定）。
3. A^c ≤m A であり、A が RE なので、A^c も RE である（REへの帰着はRE）。
4. 言語 A とその補問題 A^c が共に RE ならば、A は判定可能 (Decidable) である。
   （証明: A の認識機 M1 と A^c の認識機 M2 を並列実行すれば、どちらかが必ず停止して答えが出るため。）`,
    commonMistakes: "「AとA^cが帰着可能なら同じクラス」と考えがちですが、A^cがREになることがポイントです。そして、REかつco-REであるクラスはDecidable（判定可能）クラスと一致するという定理を忘れないでください。"
  },
  {
    id: "3.16",
    question: "2テープ TM M が入力 w に対し、第2テープに非空文字を書き込むかどうかを決定する問題は判定不可能であることを示せ。",
    answer: "A_TM からの帰着。",
    explanation: "「受理するときだけ第2テープに書く」ような機械を作れば、その判定は受理性の判定と同じになります。",
    formalProof: `この問題を Write2 と呼ぶ。A_TM から Write2 への帰着 f を構成する。
入力 <M, w> に対して、新しい TM M' を構成する:
M'(x):
  1. 入力 x (これは M' への入力だが無視する) に関わらず、M を w 上でシミュレートする。
  2. M が accept した場合のみ、第2テープに '1' を書き込む。
このとき、
- M が w を受理する ⇒ M' は第2テープに書き込む ⇒ <M'> ∈ Write2
- M が w を受理しない ⇒ M' は第2テープに書かない ⇒ <M'> ∉ Write2
この帰着は計算可能である。A_TM は判定不能なので、Write2 も判定不能である。`,
    commonMistakes: "帰着を作る際、Mをそのまま使うのではなく、Mの動作を監視して条件を満たしたときだけ特定の動作（第2テープへの書き込み）を行う「新しい機械 M'」を構成するという手順が重要です。"
  },
  {
    id: "3.17",
    question: "Riceの定理：P を非自明な言語の性質とする。L_P = { <M> : L(M) ∈ P } は判定不可能であることを示せ。",
    answer: "A_TM を L_P に帰着させる。",
    explanation: "空言語 ∅ が P に属さないと仮定し（属する場合は Pの補集合を考える）、M が受理するときだけ P に属する言語を受理する機械 M' を作ります。",
    formalProof: `一般性を失わず、∅ ∉ P と仮定する（もし ∅ ∈ P なら、P の代わりに P^c を考えればよい）。
P は非自明なので、ある言語 L ∈ P が存在し、それを認識する TM M_L が存在する。
A_TM から L_P への帰着 <M, w> → <M'> を構成する。
M'(x):
  1. M を w 上で実行する。
  2. もし M が reject すれば reject。
  3. もし M が accept すれば、M_L を x 上で実行し、その結果を返す。
解析:
- M が w を受理する場合: M' は M_L と同じ動作をする。L(M') = L(M_L) = L ∈ P。よって <M'> ∈ L_P。
- M が w を受理しない場合: M' は何も受理しない（ステップ1で止まるかreject）。L(M') = ∅ ∉ P。よって <M'> ∉ L_P。
これにより A_TM ≤m L_P となり、L_P は判定不能。`,
    commonMistakes: "Riceの定理は「言語の性質」にのみ適用されます。「状態数が10以下である」のような「機械の性質（構文的性質）」には適用できない点に注意してください。"
  },
  {
    id: "3.18",
    question: "自分自身を出力するプログラム (Quine) を作成し、再帰定理の例を与えよ。",
    answer: "Python による例。",
    explanation: "format文字列などを用いて、コード自身の構造をデータとして持ち、それを展開して出力します。",
    formalProof: `Pythonによる例:
s = 's = {0}{1}{0}; print(s.format(chr(39), s))'; print(s.format(chr(39), s))

解説:
このプログラムは文字列変数 s に自身のコードの「形式」を代入し、その s をフォーマットして出力することで、コード全体を再現する。
再帰定理（Recursion Theorem）は、任意の計算可能な変換 T に対して、動作が T(<R>) と一致するような TM R が存在することを保証する。これはプログラムが自身の記述 <R> を参照できることに相当する。`,
    commonMistakes: "ファイル読み込みを使って自身のソースコードを読むのはQuineとはみなされません。プログラム内部のロジックだけで自身を再現する必要があります。"
  },
  {
    id: "3.19",
    question: "∃c ∀x,y [ K(xy) ≤ 2 log K(x) + K(x) + K(y) + c ] を示せ。",
    answer: "x の長さを自己区切り形式で記述する。",
    explanation: "単純に x と y のプログラムを連結すると切れ目がわかりません。x の記述長を前置することで復元可能にします。",
    formalProof: `文字列 xy を出力するプログラムを構成する。
単純に <M_x><M_y> と並べると、どこまでが x の記述かわからない。
そこで、K(x) の値を自己区切り符号（例えば長さをバイナリで書き、各ビットを2回繰り返して 01 で終わるなど）で記述する。
記述全体の構成: [K(x)の自己区切り記述] [xの最短プログラム] [yの最短プログラム]。
この記述の長さは、
|K(x)の自己区切り| + K(x) + K(y)
≈ 2 log K(x) + K(x) + K(y)。
この記述を入力として、x と y を復元して連結出力する固定プログラム（サイズ c）が存在する。`,
    commonMistakes: "K(xy) <= K(x) + K(y) + c としたくなりますが、これは一般には成り立ちません（連結部分の区切りが不明なため）。自己区切り符号分のオーバーヘッド (2 log K(x)) が必要です。"
  },
  {
    id: "3.20",
    question: "長さ n の文字列全体で少なくとも 2^n - 2^{n-c+1} + 1 個は c で圧縮不可能であることを示せ。",
    answer: "記述の数が足りないことを示す（鳩の巣原理）。",
    explanation: "長さ n-c 以下の記述の総数は、文字列の総数 2^n より圧倒的に少ないため、ほとんどの文字列は圧縮できません。",
    formalProof: `記述（プログラム）の長さが n-c 以下であるような文字列の数を数える。
長さ k のバイナリ列は 2^k 個ある。
長さ 0 から n-c までの記述の総和は:
Sum_{i=0}^{n-c} 2^i = 2^{n-c+1} - 1。
これは圧縮可能な文字列の最大数である。
長さ n の文字列は全部で 2^n 個ある。
圧縮不可能な文字列の数は少なくとも:
2^n - (2^{n-c+1} - 1) = 2^n - 2^{n-c+1} + 1。
これは n が大きければ 2^n に近く、ほとんどの文字列は圧縮不可能であることを示す。`,
    commonMistakes: "「すべての文字列が圧縮可能である」という誤解（可逆圧縮の限界）を避けてください。鳩の巣原理により、必ず圧縮できない（記述長が元より短くならない）データが大多数存在します。"
  },
  {
    id: "3.21",
    question: "Kolmogorov 複雑性 K(x) は計算可能でないことを示せ。",
    answer: "Berry のパラドックスを用いる。",
    explanation: "もし K(x) が計算可能なら、「記述量が N より大きい最小の文字列」を出力する短いプログラムが書けてしまい、矛盾します。",
    formalProof: `K(x) が計算可能関数であると仮定する。
以下の TM M を構成する。
M(n):
  1. 文字列 x を辞書順に生成する (0, 1, 00, ...)。
  2. 各 x について K(x) を計算する。
  3. K(x) > n となる最初の x を見つけたら、その x を出力して停止する。
この M の記述長を C とする。M(n) は記述長 log n + C 程度のプログラムで実行できる。
しかし M(n) が出力する x は K(x) > n を満たすはずである。
十分大きな n に対して、log n + C < n となる。
すると x は「長さ log n + C の記述（M と n）」で生成されるにもかかわらず、「記述複雑性 K(x) > n」を持つことになり矛盾。
よって K(x) は計算不可能である。`,
    commonMistakes: "K(x) は上から評価すること（具体的な圧縮プログラムを示すこと）は可能ですが、下限の証明（これ以上縮まないことの証明）が一般に不可能である点がポイントです。"
  },
  {
    id: "3.22",
    question: "圧縮不可能な文字列の集合は判定不可能であることを示せ。",
    answer: "もし判定可能なら、高複雑度の文字列を簡単に見つけられる。",
    explanation: "3.21 と同様の矛盾を導きます。判定可能なら、それを使って高い K(x) を持つ x を探索できてしまいます。",
    formalProof: `S = { x : K(x) ≥ |x| } （非圧縮文字列の集合）とする。
もし S が判定可能なら、ある決定機 D が存在する。
以下のアルゴリズムで、任意の長さ n の非圧縮文字列を見つけることができる:
長さ n の文字列を順に生成し、D で判定する。3.20 より必ず存在する。
最初に見つかった x を出力する。
このアルゴリズムの記述長は定数（と n の情報）で済むが、出力される x は K(x) ≥ n を満たす。
これは n が十分大きいとき、x の複雑性が記述長 n より大きいにも関わらず、短い記述（アルゴリズム）で出力できることを意味し矛盾。`,
    commonMistakes: "判定不能であることと、存在しないことを混同しないでください。非圧縮文字列は大量に存在しますが、どれがそうであるかをアルゴリズム的に特定することができません。"
  },
  {
    id: "3.23",
    question: "圧縮不可能な文字列の集合は、Turing 認識可能な無限部分集合を含まないことを示せ。",
    answer: "無限の RE 部分集合があれば、高複雑度の文字列を列挙できる。",
    explanation: "認識可能な集合は列挙可能です。列挙できるなら、その生成手順自体が「短い記述」になり、生成される文字列の複雑性が高いことと矛盾します。",
    formalProof: `非圧縮集合 S の無限部分集合 A が RE であると仮定する。
A は RE なので、A を列挙する enumerator E が存在する。
E は無限に多くの文字列 x_1, x_2, ... を出力する。
i 番目に出力される文字列 x_i を考える。
x_i は「E を実行して i 番目に出力を待つ」というプログラムで記述できる。
このプログラムの長さは |<E>| + log i 程度である。
よって K(x_i) ≤ |<E>| + log i + c。
一方で x_i ∈ A ⊆ S なので、x_i は非圧縮であり、K(x_i) ≥ |x_i|。
E は無限に文字列を吐くので、|x_i| は i と共に増加する（少なくとも同じ文字列は一度しか出ない）。
十分に大きな i に対して、|<E>| + log i + c < |x_i| となる（|x_i| は i 程度には伸びないかもしれないが、記述長 log i は長さ |x_i| より遥かに遅く成長するため矛盾が生じる。より厳密には、Eが出力する文字列の長さには下限がないが、無限個あるため長さは無限大に発散する）。
大きな長さの文字列 x に対し、K(x) ≥ |x| だが、記述長は log (index) で抑えられるため、十分先の方で矛盾する。`,
    commonMistakes: "有限の部分集合なら当然含みます（REかつ判定可能）。「無限の」部分集合を含まない、という点が重要です。これにより、ランダム性は計算的に生成できないことが示唆されます。"
  },

  // Section 4: Complexity Theory
  {
    id: "4.1",
    question: "f(n) = 5n^3 + 2n^2 + 22n + 6 が O(n^2) ではないことを示せ。",
    answer: "極限をとって発散することを示す。",
    explanation: "n が大きくなると n^3 の項が n^2 より圧倒的に大きくなるため、定数倍で抑えられません。",
    formalProof: `背理法。f(n) = O(n^2) と仮定する。
定義より、ある定数 c, n0 > 0 が存在し、全ての n > n0 で f(n) ≤ c n^2。
5n^3 + 2n^2 + 22n + 6 ≤ c n^2
両辺を n^2 で割る:
5n + 2 + 22/n + 6/n^2 ≤ c
n → ∞ のとき、左辺は ∞ に発散するが、右辺は定数 c である。
これは矛盾。よって f(n) ≠ O(n^2)。`,
    commonMistakes: "O記法の定義における「ある定数 c が存在して」という部分を、「任意の c に対して」と混同しないように。否定する際は「どんな c を持ってきても n を大きくすれば破綻する」ことを示します。"
  },
  {
    id: "4.2",
    question: "言語 A = {0^k 1^k : k ≥ 0} が TIME(n log n) に属することを示せ。",
    answer: "2テープTMなら O(n)、1テープでも O(n log n) で可能。",
    explanation: "0と1を交互に消していくアルゴリズムなどを効率的に実装します。多テープならコピーして比較で O(n)。",
    formalProof: `2テープ Turing 機械を用いる場合:
1. 入力テープの 0 の部分を第2テープにコピーする。 O(n)
2. 入力テープのヘッドが 1 の開始位置に来たら、第2テープのヘッドを先頭に戻す。
3. 入力テープで 1 を読み進めると同時に、第2テープで 0 を読み進める。 O(n)
4. 両方の長さが一致し、同時に終了すれば accept。
全体で O(n) なので、TIME(n log n) に含まれる。
（注: 1テープTMの場合でも、Hennie-Stearns のシミュレーション定理などにより O(n log n) で可能、あるいは再帰的に半分ずつ照合するアルゴリズムで O(n log n) が達成可能。）`,
    commonMistakes: "1テープTMで愚直に往復すると O(n^2) になります。O(n log n) を達成するには、例えば「0と1を交互に半分ずつ消していく」などの工夫が必要です。"
  },
  {
    id: "4.3",
    question: "TM M について、(i) M が多項式時間である ⇔ (ii) M が O(n^k) 時間である。",
    answer: "多項式の次数による。",
    explanation: "多項式は最高次の項で抑えられるため、O(n^k) と等価です。",
    formalProof: `(i) ⇒ (ii): M の実行時間が多項式 p(n) = a_m n^m + ... + a_0 で抑えられるとする。
n ≥ 1 において p(n) ≤ (Σ|a_i|) n^m である。k=m とすれば M は O(n^k) 時間である。
(ii) ⇒ (i): M が O(n^k) 時間なら、実行時間は c n^k 以下。単項式 c n^k は多項式の一種である。`,
    commonMistakes: "ここでの k は M に依存して決まる定数であり、入力 n に依存してはいけません（例えば n^n は多項式時間ではありません）。"
  },
  {
    id: "4.4",
    question: "t(n)≥n。任意の t(n) 時間複数テープ TM は、O(t^2(n)) 時間単一テープ TM と等価であることを示せ。",
    answer: "テープを連結してシミュレート。",
    explanation: "複数のテープの内容を1本のテープに並べて書き、ヘッド位置をマークして管理すると、1ステップの処理にテープ全長 O(t(n)) かかり、全体で O(t(n)^2) になります。",
    formalProof: `k テープ TM M を単一テープ S でシミュレートする。
S のテープ構成: # T1 # T2 # ... # Tk # （各 Ti はテープ内容とヘッド位置情報を含む）。
M の 1 ステップのシミュレーション:
1. S はテープ全体を走査し、k 個のヘッド位置の記号を読み取る。 (所要時間 O(t(n)))
2. 遷移関数に従い、各ヘッド位置の記号を書き換え、ヘッドを移動する。 (所要時間 O(t(n)))
   - もし書き込みで領域が不足する場合、データを右にシフトする。最大 O(t(n))。
M は t(n) ステップ動作するので、テープ長は最大 k・t(n)。
全実行時間は Σ_{i=1}^{t(n)} O(t(n)) = O(t(n)^2)。`,
    commonMistakes: "データを右にシフトするコスト (最大 O(t(n))) を忘れてはいけません。単に書き換えるだけなら高速ですが、テープ長の拡張が必要な場合があります。"
  },
  {
    id: "4.5",
    question: "すべての文脈自由言語 (CFL) がクラス P に属することを示せ。",
    answer: "CYK法を用いる。",
    explanation: "3.9 と同様、CYKアルゴリズムにより O(n^3) で判定可能です。O(n^3) は多項式時間です。",
    formalProof: `任意の CFL L に対して、それを生成する CFG G が存在する。
G を Chomsky 標準形に変換する（定数時間/文法サイズ依存のみ）。
入力 w (|w|=n) に対して CYK アルゴリズムを適用する。
CYK は動的計画法であり、n×n のテーブルを埋める。各セルの計算は定数時間（非終端記号数の定数倍）。
全体の計算時間は O(n^3)。
O(n^3) ⊆ P なので、L ∈ P である。`,
    commonMistakes: "「文法サイズ」を入力の一部とみなすかどうかに注意が必要です。この問題では言語 L を固定して考えるため、文法サイズは定数とみなせますが、一般の <G, w> に対しても多項式時間です。"
  },
  {
    id: "4.6",
    question: "f が多項式時間計算可能なとき、Iter_f(0^n, x) := f^n(x) は多項式時間か？",
    answer: "いいえ、出力長が指数的に増える場合があります。",
    explanation: "f(x) = xx のような関数を考えると、n回適用で長さが 2^n 倍になり、書き出すだけで指数時間かかります。",
    formalProof: `反例: f(x) = x0 + x1 （ビット連結、あるいは単純に f(x) = xx）。
ここでは f(x) = xx (文字列の2回繰り返し) とする。
|f(x)| = 2|x|。
Iter_f(0^n, x) を計算すると、1回適用で2倍、n回適用で 2^n 倍の長さになる。
出力文字列の長さが |x|・2^n となり、n に対して指数関数的である。
多項式時間 TM は多項式長の出力しか生成できないため、これを計算（出力）することはできない。
よって多項式時間計算可能ではない。`,
    commonMistakes: "「fの計算が多項式時間だから、それをn回やっても多項式時間」という直感は誤りです。n回の反復によって入力サイズが膨張する場合、1回のステップにかかる時間も増大します。"
  },
  {
    id: "4.7",
    question: "論理式 (x∨y)∧(x∨¬y)∧(¬x∨y)∧(¬x∧¬y) は充足可能か？",
    answer: "充足不可能。",
    explanation: "すべての節を満たす真理値割り当てが存在しません。",
    formalProof: `各節をチェックする。
1. (¬x ∧ ¬y) が真 ⇒ x=F, y=F。
このとき第1節 (x ∨ y) は (F ∨ F) = F となり偽。
よって全体を真にする割り当ては存在しない。
(Resolution法などを用いても、空節が導かれるため unsatisfiable)`,
    commonMistakes: "各節を個別に満たすことは可能ですが、すべての節を「同時に」満たす共通の割り当てを探す必要がある点を忘れないようにしましょう。"
  },
  {
    id: "4.8",
    question: "SAT が NP 完全であることを NP 完全性の定義に基づいて証明せよ (Cook-Levin)。",
    answer: "検証機の計算履歴を論理式で表現する。",
    explanation: "任意の NP 問題の計算過程（状態遷移、テープ内容）を論理変数と節で表現し、「計算が受理状態で終わる」ことと「論理式が充足可能である」ことを等価にします。",
    formalProof: `1. SAT ∈ NP は明らか（割り当てを証拠として線形時間検証）。
2. 任意の A ∈ NP に対して A ≤p SAT を示す。
A を判定する非決定性 TM N が n^k 時間で走るとする。
入力 w に対する N の計算過程（Tableau）を考える。
Tableau は (n^k) × (n^k) のグリッドで、各セルはテープ記号や状態を持つ。
変数 X_{i,j,s} を「時刻 i, 位置 j のセルが記号 s である」として定義する。
以下の条件を論理式 φ で記述する:
- 各セルはただ1つの記号を持つ。
- 初期構成が正当である (w が入力)。
- 遷移が N の規則に従っている (2×3 のウィンドウ等で局所チェック)。
- 最終的に受理状態を含む。
φ は多項式サイズで構成でき、N が w を受理する経路が存在することと φ が充足可能であることは同値。
よって SAT は NP 完全。`,
    commonMistakes: "「SATから他の問題への帰着」を示すのではなく、「任意のNP問題からSATへの帰着」を示す必要がある点（定義そのもの）に注意してください。"
  },
  {
    id: "4.9",
    question: "3SAT が NP 完全であることを示せ。",
    answer: "SAT ≤p 3SAT。",
    explanation: "任意の論理式を CNF にし、さらに長い節を分割して 3リテラル制限を満たすように変換します。",
    formalProof: `1. 3SAT ∈ NP は自明。
2. SAT (CNF-SAT) ≤p 3SAT を示す。
CNF の各節 C = (l_1 ∨ ... ∨ l_k) を考える。
- k=1: (l_1 ∨ l_1 ∨ l_1)
- k=2: (l_1 ∨ l_2 ∨ l_2)
- k=3: そのまま。
- k>3: 新しい変数 z_1, ..., z_{k-3} を導入し、
  (l_1 ∨ l_2 ∨ z_1) ∧ (¬z_1 ∨ l_3 ∨ z_2) ∧ ... ∧ (¬z_{k-3} ∨ l_{k-1} ∨ l_k)
  に変換する。
この変換は充足可能性を保存し、多項式時間で行える。`,
    commonMistakes: "k>3 の節を分割する際、単に分割するだけではダメで、新しい変数 z を用いて「連鎖」させることで、元の節の意味（どれか1つが真なら全体も真）を保存する必要があります。"
  },
  {
    id: "4.10",
    question: "2SAT が P (多項式時間判定可能) であることを示せ。",
    answer: "含意グラフの強連結成分分解。",
    explanation: "(A ∨ B) を (¬A → B) 等の有向辺とみなし、矛盾する推論 (x → ¬x かつ ¬x → x) があるか探します。",
    formalProof: `2CNF の各節 (a ∨ b) を含意形 (¬a → b) ∧ (¬b → a) に変換し、有向グラフ G を作る（頂点はリテラル）。
論理式が充足不能 ⇔ ある変数 x について、x から ¬x へのパスと、¬x から x へのパスが共に存在する。
これは x と ¬x が同じ強連結成分 (SCC) に属することと同値。
SCC 分解は Tarjan のアルゴリズム等で線形時間 O(V+E) で可能。
よって 2SAT は多項式時間で判定可能。`,
    commonMistakes: "3SAT が NP 完全だからといって、2SAT も難しいだろうと推測してはいけません。制約が強くなると（1節あたりのリテラルが減ると）逆に問題の構造が単純になり、解きやすくなります。"
  },
  {
    id: "4.11",
    question: "VertexCover が NP 完全であることを示せ。",
    answer: "3SAT ≤p VertexCover。",
    explanation: "論理式の変数と節をグラフの部品（ガジェット）に変換し、充足可能なら特定のサイズの頂点被覆が存在するようにします。",
    formalProof: `1. VC ∈ NP (被覆集合を証拠として検証)。
2. 3SAT ≤p VC。
3CNF φ からグラフ G を構成。
- 各変数 x_i に「変数ガジェット」: 頂点 x_i, ¬x_i を辺で結ぶ。
- 各節 C_j = (l1 ∨ l2 ∨ l3) に「節ガジェット」: 3頂点を三角形に結ぶ。
- 変数ガジェットと節ガジェットを接続: 節のリテラルに対応する変数頂点と辺で結ぶ。
k = (変数の数) + 2×(節の数) とする。
φ が充足可能 ⇔ G がサイズ k の頂点被覆を持つ。
（変数は真のリテラルを選び、節は満たされたリテラル以外の2頂点を選ぶことで被覆できる）`,
    commonMistakes: "頂点被覆 (Vertex Cover) と独立集合 (Independent Set) は互いに補集合の関係にあり、どちらも NP 完全です。証明の際にガジェットの構成を混同しないようにしましょう。"
  },
  {
    id: "4.12",
    question: "HamPath が NP 完全であることを示せ。",
    answer: "3SAT ≤p HamPath (または Directed HamPath)。",
    explanation: "3SAT の変数をダイヤモンド型ガジェット、節をノードに変換し、これらを一筆書きできるかが充足性と等価になるように繋ぎます。",
    formalProof: `1. HamPath ∈ NP。
2. 3SAT ≤p DirectedHamPath (標準的な教科書の証明)。
変数ごとに、左右のパスを選べるダイヤモンドガジェットを作る。
節ごとに、パスが立ち寄れるノードを作る。
変数の真偽に応じてパスの向きが決まり、その途中で節ノードを回収（訪問）できるかどうかが、充足性に対応する。
全変数のガジェットを直列に繋ぎ、始点から終点まで全ての節を経由して到達できるなら、充足割り当てが存在する。`,
    commonMistakes: "Euler路（辺を一回ずつ通る、Pで解ける）とHamilton路（頂点を一回ずつ通る、NP完全）を混同しないこと。この証明はガジェット構成が複雑なので、直感的な流れをまず理解することが重要です。"
  },
  {
    id: "4.13",
    question: "GraphIso (グラフ同型) が NP に属することを示せ。",
    answer: "同型写像を証拠とする。",
    explanation: "頂点の対応関係（置換）が与えられれば、辺の接続関係が一致するかは簡単にチェックできます。",
    formalProof: `入力: <G, H>。
証拠 (Certificate): G の頂点から H の頂点への全単射写像 π。
検証機 V:
1. π が全単射か確認。
2. G の任意の2頂点 u, v について、(u, v) ∈ E(G) ⇔ (π(u), π(v)) ∈ E(H) を確認する。
これは多項式時間 O(V^2) で実行可能。
よって GraphIso ∈ NP。`,
    commonMistakes: "GraphIso は NP 完全であるかどうか未解決の問題（NP Intermediate の候補）です。「NP 完全であることを示せ」という問題ではない点に注意してください。"
  },
  {
    id: "4.14",
    question: "Connected (連結性) が P に属することを示せ。",
    answer: "探索アルゴリズム (BFS/DFS) を使う。",
    explanation: "ある頂点からたどれる全ての頂点を数え、全頂点数と一致すれば連結です。",
    formalProof: `アルゴリズム:
1. グラフの任意の頂点 s を選ぶ。
2. s から BFS (または DFS) を開始し、到達可能な頂点集合 R を求める。
3. |R| = |V| (全頂点数) なら accept、そうでなければ reject。
BFS/DFS は O(V+E) で動作し、これは入力サイズの多項式時間である。`,
    commonMistakes: "連結性は非常に基本的な性質であり、計算量は小さい (ほぼ線形時間) です。複雑に考えすぎないようにしましょう。"
  },
  {
    id: "4.15",
    question: "Partition が NP 完全であることを示せ。",
    answer: "SubsetSum ≤p Partition。",
    explanation: "SubsetSum のインスタンスを Partition のインスタンスに変換します。ターゲット数との差分調整などを用います。",
    formalProof: `1. Partition ∈ NP。
2. SubsetSum ≤p Partition。
SubsetSum 入力: 集合 S = {x_1, ..., x_n}, ターゲット t。
S の総和を σ とする。
Partition 用の集合 S' を構成する:
S' = S ∪ { 2t - σ, σ + t } （少し工夫が必要）。
一般的な変換:
S' = {x_1, ..., x_n, J, K} とする。
目標は総和 Σ' の半分になること。
単純な構成: J = 2Σ - t, K = Σ + t のような非常に大きな数を追加し、バランスを取ることで、元の S の部分和が t になる場合のみ分割可能にする。
（詳細構成: S の総和を m とする。SubsetSum <S, t> に対し、Partition <S ∪ {2m-t, m+t}> を考える。総和は m + 3m = 4m。半分は 2m。
片方が m+t を含むなら、残りの枠は 2m - (m+t) = m-t。
もう片方は 2m-t を含み、残りは t。
つまり S の中から和が t (または m-t) になる部分集合を選べるかと同値になる。）`,
    commonMistakes: "Partition は SubsetSum の特殊ケース（ターゲットが総和の半分）に見えますが、帰着の方向は「一般 (SubsetSum) → 特殊 (Partition)」を示す必要があります。特殊ケースだから簡単、ではない点に注意。"
  },
  {
    id: "4.16",
    question: "3Color が NP 完全であることを示せ。",
    answer: "3SAT ≤p 3Color。",
    explanation: "True/False/Base の色パレットと、OR演算を模倣するガジェットを用いて、論理式をグラフ彩色問題に変換します。",
    formalProof: `1. 3Color ∈ NP。
2. 3SAT ≤p 3Color。
パレットガジェット: 3頂点 (T, F, B) を互いに結ぶ (三角形)。これで3色が定義される。
変数ガジェット: 各 x_i について、x_i と ¬x_i を結び、さらに両方を B と結ぶ。これにより x_i は T か F の色しか取れない。
節ガジェット: OR 演算を模倣するサブグラフを構成し、リテラルのどれかが T 色なら全体を彩色できるようにする。
全体が 3彩色可能 ⇔ すべての節ガジェットが整合的に彩色可能 ⇔ 充足割り当てが存在。`,
    commonMistakes: "2彩色（2部グラフ判定）は多項式時間で解けますが、3彩色は NP 完全です。k-彩色問題において k≧3 で難易度が跳ね上がる点を確認しましょう。"
  },
  {
    id: "4.17",
    question: "TQBF が PSPACE 困難であることを証明せよ。",
    answer: "多項式空間 TM の動作を論理式で表現。",
    explanation: "Savitch の定理のように、構成 C1 から C2 へ到達可能かを再帰的に分割し、量化子を使って式サイズを抑えます。",
    formalProof: `任意の PSPACE 言語 L を判定する機械 M (空間 n^k) を考える。
CanReach(C1, C2, t) を「構成 C1 から C2 へ t ステップ以内で到達可能か」という論理式とする。
t = 1 なら、遷移関数のローカルチェック (多項式サイズ)。
t > 1 のとき、中間点 Cm を存在させ、前半と後半に分ける。
CanReach(C1, C2, t) ≡ ∃Cm ∀(C_start, C_end) ∈ {(C1, Cm), (Cm, C2)} [ CanReach(C_start, C_end, t/2) ]
（∀を使うことで同じ式を2回書かずに済み、サイズ爆発を防ぐ）。
再帰深さは log(2^{n^k}) = O(n^k)。
最終的に得られる TQBF は多項式サイズであり、M の受理と同値。`,
    commonMistakes: "Cook-Levin (SAT) の証明と同様に論理式を展開しようとすると、ステップ数が指数的なので式のサイズも指数的になってしまいます。量化子 ∀ をうまく使って式を圧縮するテクニック（Savitchの定理の論理式版）が必須です。"
  },
  {
    id: "4.18",
    question: "中身が CNF である TQBF も PSPACE 完全であることを示せ。",
    answer: "変数を追加して CNF 化する。",
    explanation: "任意の論理式は、新しい変数を導入することで等価な CNF に変換できます。量化子のプレフィックスには影響しません。",
    formalProof: `任意の TQBF Φ = Q_1 x_1 ... Q_m x_m φ(x) を考える。
φ(x) (量化子のない部分) に対して、論理回路から CNF への変換 (Tseitin transformation) を適用する。
各ゲートの出力に新しい変数を割り当て、ゲートの入出力関係を表す CNF 節を追加する。
新しい変数 y_1, ..., y_k を存在量化子で束縛し、量化子の最内層に配置する。
Φ' = Q_1 x_1 ... Q_m x_m ∃y_1 ... ∃y_k (CNF化されたφ)。
これは元の Φ と真偽が一致し、中身は CNF である。
よってこの形式も PSPACE 完全。`,
    commonMistakes: "量化子の順序（∀∃の交代）こそがゲームの複雑さを生む要因であり、最内層の論理式が簡単（CNFやDNF）であっても PSPACE 困難性は変わりません。"
  },
  {
    id: "4.19",
    question: "任意の PSPACE 困難言語は NP 困難であることを示せ。",
    answer: "NP ⊆ PSPACE より。",
    explanation: "PSPACE困難は「全てのPSPACE問題が帰着できる」こと。NP問題もPSPACEに含まれるので、当然帰着できます。",
    formalProof: `A を PSPACE 困難言語とする。定義より、∀L ∈ PSPACE, L ≤p A。
ここで NP ⊆ PSPACE である（証明: NP の計算木深さは多項式、DFSで多項式空間でシミュレート可能）。
したがって、∀L' ∈ NP, L' ∈ PSPACE であり、L' ≤p A が成り立つ。
これは A が NP 困難であることの定義そのものである。`,
    commonMistakes: "「難しい問題はより簡単な問題も包含する」という直感を形式的に記述するだけですが、定義（帰着可能性）に戻って確認することが重要です。"
  },
  {
    id: "4.20",
    question: "NL 完全性の定義に多項式時間帰着を用いるとどうなるか？",
    answer: "NL ⊆ P なので、全ての P の問題が NL 完全になり区別不能になる。",
    explanation: "帰着自体の計算能力が高すぎると、クラス内部の細かい難易度差が見えなくなります。対数領域帰着が必要です。",
    formalProof: `もし NL 完全性を「多項式時間帰着 ≤p」で定義すると：
NL ⊆ P であることが知られている。
もし NL ≠ P であったとしても、任意の L ∈ P (L≠∅, Σ*) は、自明な NL 問題（例えば {1}）に ≤p で帰着できてしまう（帰着関数が L を解いて、結果に応じて定数を出力すればよい）。
これでは「NL 完全」というクラスが P 全体と一致してしまい、NL 固有の難しさを特徴づけられない。
より弱い帰着（対数領域帰着 ≤L）を用いることで、P 内部の構造 (NL vs P) を議論できる。`,
    commonMistakes: "帰着関数自体が問題を解いてしまってはいけません。帰着は「変換」だけを担当するべきです。P内部のクラスを議論するのにP時間帰着を使うと、変換中に問題を解けてしまう可能性があります。"
  },
  {
    id: "4.21",
    question: "f(n)≥n のとき、SPACE(f(n)) は1テープでも2テープでも同値であることを示せ。",
    answer: "入力テープを1本に統合しても定数倍しか変わらない。",
    explanation: "f(n)≥n なら入力全体を書き直すスペースがあるため、作業領域と入力を同じテープに置けます。",
    formalProof: `2テープ (入力+作業) TM M が f(n) 空間を使うとする。
1テープ TM S でシミュレートする場合、入力 w をそのままテープに置く（長さ n）。
f(n) ≥ n なので、作業領域として使う分も含めて、テープ上の使用量は O(f(n)) に収まる。
（具体的には、入力記号と作業記号を同じセルで管理するか、入力をシフトしてスペースを作る。空間は O(n + f(n)) = O(f(n)) となる。）
よって空間計算量のクラスは変わらない。`,
    commonMistakes: "f(n) < n (対数空間など) の場合は話が別です。入力テープが読み取り専用で別になっていないと、入力を置くだけで O(n) 食ってしまい、対数空間クラスを定義できなくなります。"
  },
  {
    id: "4.22",
    question: "NL ⊆ P を示せ。",
    answer: "PATH (到達可能性) ∈ P。",
    explanation: "NL完全問題である PATH は BFS/DFS で多項式時間で解けます。",
    formalProof: `NL 完全問題である PATH (有向グラフの到達可能性) を考える。
任意の NL 問題 A は PATH に対数領域帰着できる (A ≤L PATH)。
対数領域帰着は多項式時間帰着でもある (A ≤p PATH)。
PATH は BFS 等により多項式時間で解ける (PATH ∈ P)。
A ≤p PATH かつ PATH ∈ P なので、A ∈ P。
よって NL ⊆ P。`,
    commonMistakes: "「非決定性があるから指数時間かかる」というのは NTM の一般的な話ですが、空間が対数に制限されている場合、可能な状態数（構成数）が多項式個しかないため、時間は多項式で済みます。"
  },
  {
    id: "4.23",
    question: "Add (加算) ∈ L を示せ。",
    answer: "繰り上がりだけ覚えて筆算。",
    explanation: "下の桁から順に計算し、キャリーだけ記憶すればよいので、指数の位置を覚える対数領域で済みます。",
    formalProof: `入力 a, b, c の i ビット目が整合しているか確認する。
アルゴリズム:
キャリー C = 0 とする。
i = 0 から n までループ:
  a_i, b_i を読み取る (入力テープ上でヘッドを移動)。
  sum = a_i + b_i + C。
  bit = sum % 2, C = sum // 2。
  c_i と bit が一致するか確認。違えば reject。
ループ終了後、C=0 なら accept。
必要な記憶領域はループ変数 i (log n ビット) とキャリー C (定数ビット) のみ。
よって O(log n) 空間 (クラス L) で計算可能。`,
    commonMistakes: "計算結果全体を保存しようとすると O(n) 空間になってしまいます。L クラスの問題では、出力テープ（書き込み専用）があるか、あるいは判定問題として解く（iビット目が正しいか確認する）必要があります。"
  },
  {
    id: "4.24",
    question: "Mult (乗算) ∈ L を示せ。",
    answer: "部分積の和を対数領域で計算。",
    explanation: "乗算は多数の加算の繰り返しです。各ビットの計算に必要なのは入力の参照とカウンタだけです。",
    formalProof: `c の k ビット目を検証する。
c_k = (Σ_{i+j=k} a_i * b_j + carry) mod 2。
この式だけでは carry の依存関係が深いが、実は乗算など基本的な算術演算は TC0 ⊆ L に含まれることが知られている。
（単純な証明: 複数の数の足し算は L で可能。乗算はシフトして足し算。ただし、中間結果を全て保持すると O(n) 空間食う。
もっと賢い方法: Beame et al. (1986) により、除算・乗算は L どころか NC1 等に含まれる。
ここでは「筆算の各ビットを再計算する」ような構成で、O(log n) 空間で可能であることを認めるのが一般的。）`,
    commonMistakes: "加算と同様、中間結果をすべて保持してはいけません。必要なビットをその都度再計算する（時間はかかるが空間は節約する）アプローチが必要です。"
  },
  {
    id: "4.25",
    question: "A_DFA ∈ L を示せ。",
    answer: "現在の状態だけ覚えればよい。",
    explanation: "DFA の状態遷移をシミュレートする際、必要なメモリは「今の状態」だけです。状態数は定数（入力の一部と見なしても対数）。",
    formalProof: `入力 <M, w>。
シミュレーションに必要な情報:
1. 現在の M の状態 q (log |Q| ビット)
2. w のヘッド位置 (log |w| ビット)
これらは共に対数空間 O(log n) に収まる。
動作:
現在の q と w の文字を見て、遷移表から次の q を求め、ヘッドを進める。
w を読み終わった時点で受理状態なら accept。
これは L に属する。`,
    commonMistakes: "DFA 自体の記述サイズを入力サイズとして考慮する場合、状態数は定数ではなく入力依存になりますが、それでも状態IDは O(log |Q|) で表現できるため、対数空間に収まります。"
  },
  {
    id: "4.26",
    question: "A_NFA は NL 完全であることを示せ。",
    answer: "PATH 問題と等価。",
    explanation: "NFA の受理判定は、状態遷移グラフ上の到達可能性問題そのものです。",
    formalProof: `1. A_NFA ∈ NL:
非決定性 TM で、NFA の遷移をそのままシミュレートする。必要な空間は現在状態とヘッド位置 (O(log n))。
2. PATH ≤L A_NFA:
有向グラフ G, s, t が与えられたとき、G を NFA とみなす（各辺を文字 'a' で遷移など）。
入力 w = a^k (k=|V|) などを考える必要はなく、ε遷移のみのNFAとみなせば、s から t へ行けるか ⇔ NFA が空文字列を受理するか。
よって NL 完全。`,
    commonMistakes: "DFAへの変換（サブセット構成法）を行うと、状態数が指数的に増えるため、対数空間では変換できません。非決定性のまま探索する必要があります。"
  },
  {
    id: "4.27",
    question: "E_DFA は NL 完全であることを示せ。",
    answer: "PATH の補問題 (co-PATH) と等価。",
    explanation: "DFA の言語が空 ⇔ 開始状態から受理状態へ到達不可能。これは到達不能性問題です。NL=coNL なので NL 完全。",
    formalProof: `E_DFA = { <M> : L(M) = ∅ }。
これは「M の遷移グラフにおいて、開始状態から任意の受理状態へのパスが存在しない」ことと同値。
つまり PATH 問題の補問題 (co-PATH) の特殊形である。
Immerman–Szelepcsényi の定理より NL = coNL なので、PATH ∈ NL ⇔ co-PATH ∈ NL。
よって E_DFA ∈ NL。
完全性は、PATH のインスタンスを E_DFA に帰着させる（t を唯一の受理状態とし、到達可能なら空でないとする）ことで示せる。`,
    commonMistakes: "「補問題だから難しい」という直感は、NL (非決定性対数領域) においては Immerman–Szelepcsényi の定理により覆されます。NL = co-NL であるため、到達不能性も NL で解けます。"
  },
  {
    id: "4.28",
    question: "Cycle (有向閉路存在) は NL 完全であることを示せ。",
    answer: "PATH からの帰着。",
    explanation: "閉路検出は探索で可能 (NL)。PATH(s, t) は s->t の辺があるかと t->s のパスがあるか (閉路) に関連付けられます。",
    formalProof: `1. Cycle ∈ NL:
非決定的に頂点 v を選び、v から出発して v に戻るパスを探索する。対数空間で可能。
2. PATH ≤L Cycle:
入力 <G, s, t>。新しいグラフ G' を作る。
G' は G に辺 (t, s) を追加したもの。
G' に閉路がある ⇔ G で s から t へのパスがある（元の G がDAGであると仮定するか、あるいは各辺を細分して長さを稼ぐなど工夫して、既存の閉路と区別する）。
厳密には、全ての頂点ペア (u, v) について PATH(u, v) を判定することで強連結成分分解も NL で可能だが、単純に PATH ≤L Cycle を示すには、
s-t パス以外の閉路がないグラフ（例: 層状グラフ）に変換してから (t, s) を足せばよい。`,
    commonMistakes: "無向グラフの閉路検出は L (対数空間) で解けることが知られていますが (Reingold, 2008)、有向グラフの場合は NL 完全です。向きの有無による難易度の違いに注意しましょう。"
  }
];
